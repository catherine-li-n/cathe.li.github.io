<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="Go并发 [ catherine's blog ] "><meta name="theme-color" content="#ebc65a"><title>Go并发 [ catherine's blog ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">catherine's blog</a></h1><p></p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">Go并发</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">Go并发</a></h2><span class="post__date">2020-09-22</span><a href="/tags/go/"><span class="post__tags">#go</span></a><a href="/tags/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"><span class="post__tags">#go基础学习</span></a></div></div><div class="article__content"><p>Go 并发</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过go关键字实现了，其实就是一个普通的函数<br><code>go hello(a,b,c)</code><br>Demo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> I := <span class="hljs-number">0</span>; I &lt; <span class="hljs-number">5</span>; I++&#123;<br>		runtime.Gosched()<br>		fmt.Println(s)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">go</span> say(“world”)<br>	say(“hello”)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多个goroutine运行在同一个进程里面，共享内存数据<br><strong>通过通信来共享，而不要通过共享来通信</strong></p>
<blockquote>
<p><code>runtime.Gosched()</code> 表示让cpu把时间片让给别人，下次某个时候继续恢复执行该goroutine  </p>
</blockquote>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p>Goroutine 之间进行数据通信：channel。<br>定义channel时，也需要定义发送到channel的值的类型<br>必须使用make创建channel</p>
<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好。无缓冲channel是在多个goroutine之间同步很棒的工具</p>
<h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>可以通过<code>ch := make(chan type, value)</code>指定缓冲大小</p>
<h3 id="Range-amp-amp-Close"><a href="#Range-amp-amp-Close" class="headerlink" title="Range &amp;&amp; Close"></a>Range &amp;&amp; Close</h3><p>通过<code>for i := range c</code>能够不断读取channel里面的数据，直到该channel被显式的关闭。上面代码我们看到可以显式的关闭channel，生产者通过内置函数close 关闭channel，且可以通过<code>v, ok := &lt;- ch</code>来测试channel是否被关闭如果返回false 则说明channel已经没有任何数据且已经被关闭</p>
<h3 id="多个channels的情况"><a href="#多个channels的情况" class="headerlink" title="多个channels的情况"></a>多个channels的情况</h3><p>Go 里面提供了一个关键字 select，通过 select 可以监听 channel 上的数据流动。<br><strong>select</strong> 默认是阻塞的，只有当监听的 channel 中有发送或接收可以进行时才会运行，当多个 channel 都准备好的时候，select 是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>	o := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>			<span class="hljs-keyword">select</span> &#123;<br>			<span class="hljs-keyword">case</span> v := &lt;- c:<br>				<span class="hljs-built_in">println</span>(v)<br>			<span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">5</span> * time.*Second*):<br>				<span class="hljs-built_in">println</span>(“timeout”)<br>				o &lt;- <span class="hljs-literal">true</span><br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>	&#125;()<br>	&lt;- o<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Select 来设置超时，可处理goroutine的超时情况</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    o := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>                <span class="hljs-keyword">case</span> v := &lt;- c:<br>                    <span class="hljs-built_in">println</span>(v)<br>                <span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">5</span> * time.Second):<br>                    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timeout&quot;</span>)<br>                    o &lt;- <span class="hljs-literal">true</span><br>                    <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    &lt;- o<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="runtime-goroutine-中的几个方法"><a href="#runtime-goroutine-中的几个方法" class="headerlink" title="runtime goroutine 中的几个方法"></a>runtime goroutine 中的几个方法</h2><ul>
<li>Goexit</li>
</ul>
<p>退出当前执行的 goroutine，但是 defer 函数还会继续调用</p>
<ul>
<li>Gosched  ｜ go schedule</li>
</ul>
<p>让出当前 goroutine 的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
<ul>
<li>NumCPU</li>
</ul>
<p>返回 CPU 核数量</p>
<ul>
<li>NumGoroutine</li>
</ul>
<p>返回正在执行和排队的任务总数</p>
<ul>
<li>GOMAXPROCS</li>
</ul>
<p>用来设置可以并行计算的 CPU 核数的最大值，并返回之前的值。</p>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/yours">Github</a></li><li><a target="_blank" rel="noopener" href="https://codepen.io/yours">Codepen</a></li><li><a target="_blank" rel="noopener" href="https://dribbble.com/yours">Dribbble</a></li><li><a target="_blank" rel="noopener" href="https://twitter.com/yours">Twitter</a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/yours">知乎</a></li><li><a target="_blank" rel="noopener" href="https://juejin.im/user/yours">掘金</a></li><li><a href="mailto:xxx@yourmail.xxxx">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Django/">Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7-%E8%A7%84%E8%8C%83/">工具/规范</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/">跨平台</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gin/" rel="tag">Gin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueJs/" rel="tag">VueJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag">go基础学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodeJS/" rel="tag">nodeJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/utils/" rel="tag">utils</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/" rel="tag">跨平台</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2020/09/23/Go%20Web%E7%BC%96%E7%A8%8B/">Go Web编程</a><a class="next-button" href="/2020/09/21/Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">Go面向对象</a></div></div></div></div><div class="footer"><span>©️2019-2020 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>